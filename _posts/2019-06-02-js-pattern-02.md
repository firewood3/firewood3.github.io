# 3장 리터럴과 생성자
자바스크립트의 리터럴 표기법 패턴을 사용하면 좀더 정확하고 에러율은 낮은 방식으로 객체를 정의할 수 있다.

## 3.1 객체 리터럴
```js
// 리터럴 사용
var car = {goes: "far"};

// 내장 생성자 함수 사용
// 안티패턴
var car = new Object();
car.goes = "far";
```
리터럴 표기법의 장점
- 더 짧다.
- 객체란 단지 이름-값 쌍의 해시 테이블(프로퍼티의 모음)임을 확실히 보여준다.

내장 생성자 함수의 단점
- 지역 유효범위에 동일한 이름의 생성자가 있을 수 있기 때문에 Object()를 호출한 위치에서부터 전역 Object 생성자까지 인터프리터가 쭉 거슬러 올라가며 유효범위를 검색해야한다.

인터프리터의 유효범위 검색 발생(Object 함수의 위치를 찾는다.)
```js
function abcd() {
    var Object = function() {
    	this.a = 1;
    }
    var obj = new Object();
    console.log(obj);   // {a: 1}
    console.log(obj.a); // 1
}
```

>"new Object()를 사용하지 말고, 객체 리터럴을 사용하라!"

## 3.2 사용자 정의 생성자 함수
직접 생성자 함수를 만들어 객체를 생성할 수 있다.

다음 코드는 자바에서 Person이라는 클래스를 사용하여 객체를 생성하는 방식과 유사하다.
```js
var adam = new Person("Adam");
adam.say(); // "I am Adam"
```

다음 코드는 Person 생성자 함수를 정의한 코드이다.
```js
var Person = function (name) {
    this.name = name;
    this.say = function() {
        return "I am " + this.name;
    }
}
```

Person 생성자 함수를 자세히 들여다보면 다음 코드와 같은 방식으로 작동한다.
```js
var Person = function (name) {
    // 객체 리터럴로 새로운 객체를 생성한다.
    // var this = {};

    // 프로퍼티와 메서드를 추가한다.
    this.name = name;
    this.say = function () {
        return "I am " + this.name;
    };

    // this를 반환한다.
    // return this;
}
```

## 3.3 new를 강제하는 패턴
생성자를 호출할 때 new를 빼고 호출하면 생성자 내부의 this는 전역객체를 가리키게 된다.(브라우저에서라면 this는 window를 가리킨다.)

다음 코드는 new를 빼고 생성자를 호출한 코드이다.
```js
function Cup() {
    this.name = "mug";
}

// new를 사용하여 호출
var cup = new Cup();
cup.name // mug

// new를 생략하여 호출
var cup = Cup();
cup.name // cannot read property 'name'

// 전역객체에 name이 프로퍼티가 생성됨
name // mug
```

생성자를 호출 할때 new를 빼면 문법오류나 런타임 에러가 발생하지는 않지만, 논리적인 오류가 생겨 예기치 못한 결과가 나올 수 있다.




